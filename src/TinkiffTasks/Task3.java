package TinkiffTasks;

/*У Кати насыщенный день на работе. Ей надо передать n разных договоров коллегам. Все встречи происходят на разных этажах,
а между этажами можно перемещаться только по лестничным пролетам — считается, что это улучшает физическую форму сотрудников.
Прохождение каждого пролета занимает ровно 1 минуту.

Сейчас Катя на парковочном этаже, планирует свой маршрут. Коллег можно посетить в любом порядке, но один из них покинет
офис через t минут. С парковочного этажа лестницы нет — только лифт, на котором можно подняться на любой этаж.

В итоге план Кати следующий:


Подняться на лифте на произвольный этаж. Считается, что лифт поднимается на любой этаж за 0 минут.
Передать всем коллегам договоры, перемещаясь между этажами по лестнице. Считается, что договоры на этаже передаются мгновенно.
В первые t минут передать договор тому коллеге, который планирует уйти.
Пройти минимальное количество лестничных пролетов.
Помогите Кате выполнить все пункты ее плана.


Формат входных данных

В первой строке вводятся целые положительные числа n и t  (2<= n,t <= 100) — количество сотрудников и время, когда один из
сотрудников покинет офис (в минутах). В следующей строке n чисел — номера этажей, на которых находятся сотрудники.
Все числа различны и по абсолютной величине не превосходят 100. Номера этажей даны в порядке возрастания.
 В следующей строке записан номер сотрудника, который уйдет через t минут.


Формат выходных данных

Выведите одно число — минимально возможное число лестничных пролетов, которое понадобится пройти Кате.


Замечание

В первом примере времени достаточно, чтобы Катя поднялась по этажам по порядку.

Во втором примере Кате понадобится подняться к уходящему сотруднику, а потом пройти всех остальных — например, в порядке
{1,2,3,4,6}

Примеры данных
Пример 1
5  5
1  4  9  16  25
2
вывод
24
Пример 2
6  4
1  2  3  6  8  25
5
вывод
31

*/
/*

Решение

Найдем максимум и минимум во входных данных.
Мы знаем, что ответ не меньше чем max − min. Если нельзя успеть пройти всех сотрудников
за это время, то это значит, что сотрудник успеет уйти. Тогда выгоднее всего сразу доехать до его
этажа, а потом сделать одну из двух операций — либо подняться на самый верх, а потом спуститься
вниз, либо спуститься на самый низ, а потом подняться наверх. Если уезжающий сотрудник был
на этаже x, то получившимися формулами будет max − min + max − x и max − min + x − min
соответственно, осталось только найти минимум из этих двух величин.
*/

import java.util.Scanner;

public class Task3 {

    public static void main(String[] args) {

        Scanner scanner=new Scanner(System.in);

        String string=scanner.nextLine();
        String[]strings=string.split(" ");
        int countworker=Integer.parseInt(strings[0]);//количество работников
        int time=Integer.parseInt(strings[1]);//какой то работник(торопится и уйдет через это время)-к  нему нужно прийти первым

        String floors=scanner.nextLine();
        String[]floorsmass=floors.split(" ");
        int []numberfloors=new int[floorsmass.length];//номера этажей -количество этажей равно переменной countworker

        for (int i = 0; i <floorsmass.length ; i++) {
            numberfloors[i]=Integer.parseInt(floorsmass[i]);

        }
        int employeewhogoout=scanner.nextInt();//этот работник уйдет через t время(строчка 68) к нему нужно прийти первому
        int count;//счетчик пролетов

        //частичное решение
        /*

           if ((numberfloors[employeewhogoout-1]-numberfloors[0])>time){                        //нужно добавить условие- потому что если  сотрудник №2 который уйдет через 5 минут находиться на 4 этаже
                                    //а я иду с 1го этажа, то я успею к нему дойти попорядку от 1го этажа до 4го затратя 3 минуты
        //логика подсчета тут

        //1 шаг-я обращаюсь к работнику который должен уйти первым через time время, employeewhogoout;-ему соответсвует позиция массива в этажах

        //2шаг далее я должен спуститься к минимальному этажу, благо Номера этажей даны в порядке возрастания, я спускаюсь к
        //numberfloors[0]. Время которое будет затарчено ( я был у работника который хочет уйти первым на 8 этаже а спускаться мне на 1
        //результат=8-1=7минут

        count=numberfloors[employeewhogoout-1]-numberfloors[0];
        //шаг 3-я прохожу от минимального этажа к максимальному=каждый пролет -минута
        count+=numberfloors[numberfloors.length-1]-numberfloors[0];


                    }
           else count=numberfloors[numberfloors.length-1]-numberfloors[0];

         */

//Тогда выгоднее всего сразу доехать до его
//этажа, а потом сделать одну из двух операций — либо подняться на самый верх, а потом спуститься
//вниз, либо спуститься на самый низ, а потом подняться наверх. Если уезжающий сотрудник был
//на этаже x, то получившимися формулами будет max − min + max − x и max − min + x − min
//соответственно, осталось только найти минимум из этих двух величин.
        //т.е нужно учесть 2 варианта- после уходящего сотрудника идти снизу вверх либо сверху вниз (вопрос выгоды)

        //все равно валидатор показывает частичное решение
        if ((numberfloors[employeewhogoout-1]-numberfloors[0])>time){
            int first=numberfloors[numberfloors.length-1]-numberfloors[0]+numberfloors[numberfloors.length-1]-numberfloors[employeewhogoout-1];
            int second=numberfloors[numberfloors.length-1]-numberfloors[0]+numberfloors[employeewhogoout-1]-numberfloors[0];
            if (first<second)count=first;
            else count=second;


        }


         else count=numberfloors[numberfloors.length-1]-numberfloors[0];

        System.out.println(count);
    }
}
