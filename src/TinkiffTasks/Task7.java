package TinkiffTasks;

import kotlin.text.StringsKt;



/*
В школе перед Новым Годом устраивают игру в Тайного Санту. Каждому ученику i выдается ученик a_i ,
которому он должен подарить подарок.

Костя, как администратор игры, определил каждому школьнику свое число a_i
 Но потом его коллега Маша спросила: А правда ли, что если начать цепочку подарков от школьника 1 к школьнику a_1
 потом a_{a1} и так далее, то цепочка замкнется на школьнике 1, после того, как задействует всех остальных учеников ровно
 по одному разу?

Костя не знает, правда это или нет, но он собирается изменить ровно одно число a_i
 чтобы получить конфигурацию, которая устроит Машу. Помогите ему с этим.


Формат входных данных

В первой строке находится натуральное число n— количество школьников (2 <= n<=  10^5). В следующей строке
находится n натуральных чисел a_i — ученик, который достался Тайному Санте с номером i (1 <= a_i <= n)
Формат выходных данных

В первой строке выведите два числа (1 <= x , y <= n , x <> y) — номер ученика x, которому нужно изменить число a_x
 и новое значение а_x

Должно выполняться условие a_x <> y
. Если ответов несколько — выведите любой.

Если сделать это невозможно — выведите << -1 -1>>


Замечание

В первом примере хотя бы один школьник будет дарить подарок сам себе.

Во втором примере после изменения происходят передачи подарков 1 \to 2 \to3 \to 1

Примеры данных
Пример 1
3
1  2  3
вывод
-1  -1
Пример 2
3
1  3  1
вывод
1  2
Решение

Если формализовать условие задачи, то можно увидеть, что от нас требуется сделать функциоальный граф циклом перенаправлением
одного ребра. Функциональный граф — такой ориентированный граф, что из каждой вершины выходит ровно одно ребро.
Посчитаем для каждой вершины, сколько в нее входит ребер. Если есть ровно один ученик, к
которому приходят 2 ребра, и другой ученик, к которому приходит 0 ребер, то можно попытаться
перенаправить одно из ребер в 0-ученика. Это можно сделать двумя разными способами, и если

после одного из вариантов граф оказывается циклом, то эта замена является ответом. Остальные
вершины обязательно должны иметь степень 1.
Можно заметить, что больше никаких вариантов перенаправить ребра нет. Это верно, потому
что степень ровно одной вершины уменьшится на 1, и степень ровно одной вершины увеличится на
1, а в итоге все степени должны оказаться равны 1.
Для того, чтобы проверить, что после замены граф оказался циклом, достаточно проверить
цепочку передачи подарков — она должна быть цикличной и состоять ровно из n элементов.
*/
import java.util.LinkedList;
import java.util.Scanner;
public class Task7 {

    public static void main(String[] args) {
        Scanner scanner=new Scanner(System.in);
        String s=scanner.nextLine();
        String s1=scanner.nextLine();

        String []strings=s1.split(" ");
        int []pupils=new int[strings.length];
        LinkedList<Integer>linkedList=new LinkedList<>();
        for (int i = 0; i <strings.length ; i++) {
            pupils[i]=Integer.parseInt(strings[i]);
            linkedList.add(pupils[i]);

        }
        int countpupils=Integer.parseInt(s);

        for (int i = linkedList.size()-1; i >=0 ; i--) {
            for (int j = 0; j <linkedList.size() ; j++) {
                if (linkedList.get(i)==linkedList.get(j)) {
                    System.out.println(++j + " " + (++j) );
                    break;
                }
                else {
                    System.out.println("-1 -1");
                    break;
                }
            }
            break;

        }




    }

}
