package JavaRushLevel21;

import JavaRushLevel20.SerializeTest4;

/*1. Даны IP-адрес и маска подсети, необходимо вычислить адрес сети - реализуй метод getNetAddress.
Используй операцию поразрядной конъюнкции (логическое И).

Пример:
IP-адрес: 11000000 10101000 00000001 00000010 (192.168.1.2)
Маска подсети: 11111111 11111111 11111110 00000000 (255.255.254.0)
Адрес сети: 11000000 10101000 00000000 00000000 (192.168.0.0)

2. Реализовать метод print, который выведет в консоль данные в двоичном коде. Для IP-адреса(192.168.1.2)
должна быть выведена строка "11000000 10101000 00000001 00000010"
3. Метод main не участвует в тестировании*/
public class Conunction_hard {

    public static void main(String[] args) {
        byte[] ip = new byte[]{(byte) 192, (byte) 168, 1, 2};
        byte[] mask = new byte[]{(byte) 255, (byte) 255, (byte) 254, 0};
        byte[] netAddress = getNetAddress(ip, mask);
        print(ip);          //11000000 10101000 00000001 00000010
        print(mask);        //11111111 11111111 11111110 00000000
        print(netAddress);  //11000000 10101000 00000000 00000000


    }

    public static byte[] getNetAddress(byte[] ip, byte[] mask) {
        byte[] newmass = new byte[ip.length];
        for (int i = 0; i < ip.length; i++) {
            newmass[i] = (byte) (ip[i] & mask[i]);
        }
        return newmass;
    }

    public static void print(byte[] bytes) {
//доработать
        String str="";
        for (byte v : bytes) {
            str += String.format("%8s ", Integer.toBinaryString(v&255 )).replaceAll(" " ,"0")+" ";
            //поставить пробел после format() и replace() иначе он замениться на 0


            /*
            можно было тут поставить так  bytes[i] & 255 | 256

            любое число, меньшее либо равно 255 при бинарном И с числом 255 - даст то же число,
            что и было например такое
            10101010 (170)
            &
            11111111 (255)
            =
             10101010 (170) далее, любое число,
             меньшее либо равно 255 при бинарном ИЛИ с числом 256 - даст то же число, но с единичкой впереди
             010101010 (170)
             |
             100000000 (256)
             = 110101010 (426) но поскольку мы потом отбрасывем в результате первый разряд
             ( .substring(1) ) - то получаем то же число, что и было изначально: 10101010 (170)
             */
        }
        System.out.println(str);



        /*
        StringBuilder stringBuilder=new StringBuilder();
        for (byte v: bytes){
            if (v < 0) {
                stringBuilder.append(Integer.toBinaryString(v).substring(24)).append(" ");
            } else {
                String str = Integer.toBinaryString(v);
                for (int i = 0; i < 8 - str.length(); i++) {
                    stringBuilder.append(0);
                }
                stringBuilder.append(Integer.toBinaryString(v)).append(" ");
            }
        }
        System.out.println(stringBuilder);


         */
/*При использовании метода Integer.toBinaryString() значение aByte приводится к 32-битному типу int.
Поскольку 11000000 является отрицательным числом (-64), при расширении к типу int старшие разряды заполняются
единицами, чтобы получить то же значение в 32-битном представлении. В итоге в stringBuilder записывается строка
"11111111111111111111111111000000".
С другой стороны, если попытаться преобразовать в строку двоичную запись 00000010, получим на выходе строку "10"
 (лидирующие нули в этом случае опускаются)
 нужно
 Отрезать лишние старшие биты, если число отрицательное. Если же число положительное - дополнить его строковую двоичную запись недостающими лидирующими нулями.
Сделать это можно так:*/


        //2способ  более короткий
    /* public static void print(byte[] bytes) {
     for(byte v:bytes){
         String str= String.format("%8s", Integer.toBinaryString(b&0xff)).replace(' ', 0);
         //поставить пробел после format() и replace() иначе он замениться на 0
    }

     */


        /*
256 добавляет байт к числу а substring(lеngth-8) убирает крайний левый бит,
 если битов при этом получается 9 первое действие сделано, потому что тип byte в Java хранит числа от -128 до
 127 в main было записано byte[] ip = new byte[]{(byte) 192, (byte) 168, 1, 2}; если вы выведете этот массив
 на экран, то увидите [-64, -88, 1, 2] и при преобразовании в int число останется неизменным - отрицательным,
  если такое число перевести в бинарную строку, то мы увидим что-то вроде 11111111111111111111111111111110
  чтобы перевести число из byte обратно в диапазон от 0 до 255, нужно прибавить 256 и убрать лишний 9-й бит,
   если он появится (он появляется, если число в byte положительное, тогда в бинарном представлении число не
   меняется, а добавляется только лишний бит слева) но как по мне, более красивым преобразованием является
   System.out.print(String.format("%8s",Integer.toBinaryString(c & 0xFF)).replace(' ', '0')); здесь байтовое
    число маскируется байтом 255 (см. побитовые операции), после преобразования строка бинарного числа
     дополняется пробелами слева до длины 8, и в конце остаётся заменить пробелы нулями



При преобразовании числа в двоичную запись нули старших разрядов опускаются для удобочитаемости.
 В соответствии с этим принципом для числа 55 получим двоичную строку 110111 (сокращённая запись).
  В действительности же байт, содержащий значение 55, выглядит так: 00110111. По условию задачи требуется,
  чтобы лидирующие нули в двоичной записи также были сохранены и выведены в консоль. Этого можно добиться,
  если прибавить к byte значению число 256 (в двоичной записи это 100000000). После сложения 55 и 256 получим
  100110111. То есть, мы практически получили нужную нам строку с нулями в старших разрядах - остаётся только
  отрезать лишнюю старшую единицу (например, методом .substring(1) ). Явное приведение b к типу int в данном
  случае излишне - эта операция будет произведена автоматически при выполнении операции сложения.


 Поскольку речь идёт об IP-адресе, значение b не может превышать 255: IP-адрес 4 версии протокола
  состоит из четырёх байт, например: 11000000 10101000 00000001 00000010 IP-адрес обрабатывается побайтово:
   для каждого байта получается двоичная запись по описанной ниже схеме, после чего все четыре строки
   склеиваются воедино и выводятся в консоль.

         */
    }
}

